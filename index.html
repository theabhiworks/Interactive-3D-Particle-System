<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Particle System</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050510; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #ui-layer { position: absolute; top: 20px; left: 20px; color: white; z-index: 10; pointer-events: none; text-shadow: 0px 2px 4px rgba(0,0,0,0.8); }
        .title { font-size: 28px; font-weight: bold; margin-bottom: 15px; letter-spacing: 1px; color: #fff; }
        .instruction { font-size: 16px; margin-bottom: 8px; color: #ddd; display: flex; align-items: center; gap: 8px; }
        .badge { background: #ffffff33; padding: 4px 8px; border-radius: 6px; font-weight: bold; color: #fff; }
        
        #video-container { position: absolute; bottom: 20px; right: 20px; width: 240px; height: 180px; z-index: 10; border-radius: 12px; overflow: hidden; border: 2px solid #ffffff55; transform: scaleX(-1); box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        video, #output_canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; }
        
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 18px; z-index: 20; background: rgba(0,0,0,0.7); padding: 20px 40px; border-radius: 15px; border: 1px solid #555; backdrop-filter: blur(10px); text-align: center; line-height: 1.5; }
        
        #shape-indicator { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); color: white; font-size: 28px; font-weight: bold; z-index: 10; text-transform: uppercase; letter-spacing: 6px; opacity: 0; transition: opacity 0.3s; text-shadow: 0 0 15px rgba(255,255,255,1); }
    </style>

    <!-- Dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">Initializing Camera...<br><span style="font-size: 14px; color: #aaa;">(If camera is blocked, auto-animation will begin)</span></div>
    
    <div id="ui-layer">
        <div class="title">Hand-Tracking Particles</div>
        <div class="instruction"><span class="badge">âœ‹ Move</span> Rotate scene & shift colors</div>
        <div class="instruction"><span class="badge">ðŸ‘Œ Pinch</span> Expand or shrink particles</div>
        <div class="instruction"><span class="badge">âœŠ Fist</span> Switch particle template</div>
    </div>
    
    <div id="shape-indicator">HEART</div>

    <div id="video-container">
        <video id="input_video" autoplay playsinline></video>
        <canvas id="output_canvas" width="240" height="180"></canvas>
    </div>
    
    <div id="canvas-container"></div>

    <script>
        // --- 1. THREE.JS SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 35; // Moved slightly back so large shapes fit

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Performance optimization
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const particleGroup = new THREE.Group();
        scene.add(particleGroup);

        // --- 2. GENERATE PARTICLE TEXTURE ---
        function createParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        // --- 3. SHAPE TEMPLATES MATH ---
        const numParticles = 15000;
        const shapes = [
            { name: "Heart", get: getHeart },
            { name: "Flower", get: getFlower },
            { name: "Saturn", get: getSaturn },
            { name: "Fireworks", get: getFireworks }
        ];
        let currentShapeIdx = 0;
        let shapeData = shapes.map(s => s.get());

        function getHeart() {
            const pos = new Float32Array(numParticles * 3);
            const col = new Float32Array(numParticles * 3);
            const color = new THREE.Color();
            for(let i=0; i<numParticles; i++) {
                const t = Math.random() * Math.PI * 2;
                const r = Math.random(); 
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                const z = (Math.random() - 0.5) * 4;

                pos[i*3] = x * 0.6 * r;
                pos[i*3+1] = y * 0.6 * r;
                pos[i*3+2] = z * r;

                color.setHSL(0.95 + Math.random()*0.1, 0.9, 0.6);
                col[i*3] = color.r; col[i*3+1] = color.g; col[i*3+2] = color.b;
            }
            return { pos, col };
        }

        function getFlower() {
            const pos = new Float32Array(numParticles * 3);
            const col = new Float32Array(numParticles * 3);
            const color = new THREE.Color();
            for(let i=0; i<numParticles; i++) {
                const a = i * 137.5 * (Math.PI / 180); // Phyllotaxis
                const r = 0.12 * Math.sqrt(i);
                const x = r * Math.cos(a);
                const y = r * Math.sin(a);
                const z = r * r * 0.04 - 4; // Cupped shape

                pos[i*3] = x; pos[i*3+1] = y; pos[i*3+2] = z;

                const hue = r < 5 ? 0.15 : 0.8; // Yellow center, purple petals
                color.setHSL(hue, 0.9, 0.5 + Math.random()*0.2);
                col[i*3] = color.r; col[i*3+1] = color.g; col[i*3+2] = color.b;
            }
            return { pos, col };
        }

        function getSaturn() {
            const pos = new Float32Array(numParticles * 3);
            const col = new Float32Array(numParticles * 3);
            const color = new THREE.Color();
            for(let i=0; i<numParticles; i++) {
                if (i < numParticles * 0.4) {
                    const u = Math.random(), v = Math.random();
                    const theta = u * 2.0 * Math.PI, phi = Math.acos(2.0 * v - 1.0);
                    const r = 5 + Math.random() * 0.5;
                    pos[i*3] = r * Math.sin(phi) * Math.cos(theta);
                    pos[i*3+1] = r * Math.cos(phi);
                    pos[i*3+2] = r * Math.sin(phi) * Math.sin(theta);
                    color.setHSL(0.08, 0.7, 0.5 + Math.random()*0.2);
                } else {
                    const angle = Math.random() * Math.PI * 2;
                    const r = 7 + Math.random() * 7;
                    pos[i*3] = Math.cos(angle) * r;
                    pos[i*3+1] = (Math.random() - 0.5) * 0.4;
                    pos[i*3+2] = Math.sin(angle) * r;
                    color.setHSL(0.12, 0.8, 0.6 + Math.random()*0.3);
                }
                const tilt = 0.4;
                const tmpy = pos[i*3+1], tmpz = pos[i*3+2];
                pos[i*3+1] = tmpy * Math.cos(tilt) - tmpz * Math.sin(tilt);
                pos[i*3+2] = tmpy * Math.sin(tilt) + tmpz * Math.cos(tilt);
                col[i*3] = color.r; col[i*3+1] = color.g; col[i*3+2] = color.b;
            }
            return { pos, col };
        }

        function getFireworks() {
            const pos = new Float32Array(numParticles * 3);
            const col = new Float32Array(numParticles * 3);
            const color = new THREE.Color();
            for(let i=0; i<numParticles; i++) {
                const u = Math.random(), v = Math.random();
                const theta = u * 2.0 * Math.PI, phi = Math.acos(2.0 * v - 1.0);
                const r = (Math.random() + Math.random() + Math.random()) * 6; // Gaussian distribution
                pos[i*3] = r * Math.sin(phi) * Math.cos(theta);
                pos[i*3+1] = r * Math.cos(phi);
                pos[i*3+2] = r * Math.sin(phi) * Math.sin(theta);
                color.setHSL(Math.random(), 1.0, 0.6 + Math.random()*0.3);
                col[i*3] = color.r; col[i*3+1] = color.g; col[i*3+2] = color.b;
            }
            return { pos, col };
        }

        // --- 4. GEOMETRY & SHADER MATERIAL ---
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(shapeData[0].pos), 3));
        // Renamed to customColor to prevent WebGL attribute collision issues
        geometry.setAttribute('customColor', new THREE.BufferAttribute(new Float32Array(shapeData[0].col), 3));

        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uExpansion: { value: 1.0 },
                uHueShift: { value: 0.0 },
                pointTexture: { value: createParticleTexture() }
            },
            vertexShader: `
                attribute vec3 customColor;
                varying vec3 vColor;
                uniform float uTime;
                uniform float uExpansion;
                
                void main() {
                    vColor = customColor;
                    
                    // Floating noise
                    float noiseX = sin(uTime * 2.0 + position.y * 2.0) * 0.3;
                    float noiseY = cos(uTime * 1.5 + position.x * 2.0) * 0.3;
                    float noiseZ = sin(uTime * 2.5 + position.z * 2.0) * 0.3;
                    
                    vec3 finalPos = (position + vec3(noiseX, noiseY, noiseZ)) * uExpansion;
                    vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                    
                    // FIXED: Increased baseline size to 300 so particles are highly visible
                    gl_PointSize = uExpansion * (300.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                uniform float uHueShift;
                uniform sampler2D pointTexture;

                vec3 hueShift(vec3 color, float hue) {
                    const vec3 k = vec3(0.57735, 0.57735, 0.57735);
                    float cosAngle = cos(hue * 6.28318);
                    return vec3(color * cosAngle + cross(k, color) * sin(hue * 6.28318) + k * dot(k, color) * (1.0 - cosAngle));
                }

                void main() {
                    vec4 texColor = texture2D(pointTexture, gl_PointCoord);
                    if(texColor.a < 0.1) discard; // Optimization
                    
                    vec3 shiftedColor = hueShift(vColor, uHueShift);
                    gl_FragColor = vec4(shiftedColor, texColor.a);
                }
            `,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true
        });

        const particles = new THREE.Points(geometry, material);
        particleGroup.add(particles);

        // --- 5. MEDIAPIPE HAND TRACKING & LOGIC ---
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const shapeIndicator = document.getElementById('shape-indicator');
        const loadingScreen = document.getElementById('loading');

        let targetExpansion = 1.0;
        let targetHueShift = 0.0;
        let targetRotX = 0.0;
        let targetRotY = 0.0;
        
        let lastFistTime = 0;
        let isLoaded = false;
        
        // Timeout: If camera doesn't start in 4 seconds, clear loading screen and start auto-animation
        setTimeout(() => {
            if (!isLoaded) {
                loadingScreen.style.display = 'none';
            }
        }, 4000);

        function showShapeIndicator(name) {
            shapeIndicator.innerText = name;
            shapeIndicator.style.opacity = 1;
            setTimeout(() => shapeIndicator.style.opacity = 0, 1500);
        }

        function onResults(results) {
            if (!isLoaded) {
                isLoaded = true;
                loadingScreen.style.display = 'none';
            }

            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 2});

                // 1. Rotation Mapping
                targetRotX = (landmarks[9].y - 0.5) * Math.PI;
                targetRotY = (landmarks[9].x - 0.5) * Math.PI * 2;
                
                // 2. Color Shift
                targetHueShift = landmarks[9].x;

                // 3. Pinch Detection
                const dx = landmarks[4].x - landmarks[8].x;
                const dy = landmarks[4].y - landmarks[8].y;
                const pinchDist = Math.sqrt(dx*dx + dy*dy);
                targetExpansion = Math.max(0.5, Math.min(2.5, 0.5 + (pinchDist - 0.02) * 11));

                // 4. Fist Detection
                const indexFolded = landmarks[8].y > landmarks[5].y;
                const middleFolded = landmarks[12].y > landmarks[9].y;
                const ringFolded = landmarks[16].y > landmarks[13].y;
                const pinkyFolded = landmarks[20].y > landmarks[17].y;
                
                const isFist = indexFolded && middleFolded && ringFolded && pinkyFolded;
                const now = Date.now();
                
                if (isFist && (now - lastFistTime > 1500)) {
                    currentShapeIdx = (currentShapeIdx + 1) % shapes.length;
                    showShapeIndicator(shapes[currentShapeIdx].name);
                    lastFistTime = now;
                }
            } else {
                targetExpansion = 1.0;
                targetHueShift = 0.0;
                targetRotX *= 0.95;
                targetRotY *= 0.95;
            }
            canvasCtx.restore();
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6
        });
        hands.onResults(onResults);

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 320,
            height: 240
        });
        cameraFeed.start().catch(err => console.log("Camera blocked, using fallback animation."));

        // --- 6. ANIMATION LOOP ---
        const clock = new THREE.Clock();
        let lastAutoSwitch = Date.now();

        function animate() {
            requestAnimationFrame(animate);
            
            // --- FALLBACK AUTO ANIMATION IF CAMERA IS DENIED ---
            if (!isLoaded) {
                targetRotY = Math.sin(clock.getElapsedTime() * 0.5) * 0.8;
                targetRotX = Math.cos(clock.getElapsedTime() * 0.3) * 0.4;
                targetHueShift = clock.getElapsedTime() * 0.1;
                
                if (Date.now() - lastAutoSwitch > 5000) {
                    currentShapeIdx = (currentShapeIdx + 1) % shapes.length;
                    showShapeIndicator(shapes[currentShapeIdx].name);
                    lastAutoSwitch = Date.now();
                }
            }

            // CPU Morphing Logic
            const positions = geometry.attributes.position.array;
            const colors = geometry.attributes.customColor.array;
            const targetPos = shapeData[currentShapeIdx].pos;
            const targetCol = shapeData[currentShapeIdx].col;

            for (let i = 0; i < positions.length; i++) {
                positions[i] += (targetPos[i] - positions[i]) * 0.06;
                colors[i] += (targetCol[i] - colors[i]) * 0.06;
            }
            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.customColor.needsUpdate = true;

            // GPU Uniform updates
            material.uniforms.uTime.value = clock.getElapsedTime();
            material.uniforms.uExpansion.value += (targetExpansion - material.uniforms.uExpansion.value) * 0.1;
            material.uniforms.uHueShift.value += (targetHueShift - material.uniforms.uHueShift.value) * 0.1;

            // Rotation
            particleGroup.rotation.x += (targetRotX - particleGroup.rotation.x) * 0.1;
            particleGroup.rotation.y += (targetRotY - particleGroup.rotation.y) * 0.1;
            particleGroup.rotation.z += 0.002; // Constant slow spin

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>